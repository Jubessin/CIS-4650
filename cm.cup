/*
* File Name: cm.cup
* Description: CUP specification file for the C- compiler.
*/

import absyn.*;

/* Parser code to change the way the parser reports errors (include
   line and column number of the error). */
parser code {:
    /* Change the method report_error so it will display the line and
       column of where the error occurred in the input as well as the
       reason for the error which is passed into the method in the
       String 'message'. */
    public void report_error(String message, Object info) {
        /* Create a StringBuffer called 'm' with the string 'Error' in it. */
        var m = new StringBuffer("Error");
   
        /* Check if the information passed to the method is the same
           type as the type java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {
            /* Declare a java_cup.runtime.Symbol object 's' with the
               information in the object info that is being typecasted
               as a java_cup.runtime.Symbol object. */
            var s = ((java_cup.runtime.Symbol)info);
   
            /* Check if the line number in the input is greater or
               equal to zero. */
            if (s.left >= 0) {                
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(" at line "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0)                    
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", column "+(s.right+1));
            }
        }
   
        /* Add to the end of the StringBuffer error message created in
           this method the message that was passed into this method. */
        m.append(" : "+message);
   
        /* Print the contents of the StringBuffer 'm', which contains
           an error message, out on a line. */
        System.err.println(m);
        valid = false;
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    /* Assume true at the start, but set to false with parsing errors */
    public static boolean valid = true;
:};

terminal IF, WHILE, BOOL, INT, VOID, COMMA, SEMI, RETURN;
terminal LEFT_PARENTHESES, RIGHT_PARENTHESES, LEFT_CURLY_BRACKET, RIGHT_CURLY_BRACKET, LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET;
terminal MULTIPLY, PLUS, MINUS, DIVIDE;
terminal AND, EQ, OR, ELSE, LT, GT, LE, GE, NE, UNARY, ASSIGN;
terminal String ID, NUM, TRUTH;

non terminal NameTy type_specifier;
non terminal DecList program, declaration_list;
non terminal FunctionDec fun_declaration, fun_prototype;
non terminal Dec declaration; 
non terminal VarDec var_declaration, param;
non terminal VarDecList params, param_list, local_declarations;
non terminal Exp statement, expression_stmt, expression, obool_expression, abool_expression, ubool_expression, simple_expression, additive_expression, term, signed_factor, factor, call;
non terminal IfExp selection_stmt;
non terminal WhileExp iteration_stmt;
non terminal ReturnExp return_stmt;
non terminal CompoundExp compound_stmt;
non terminal ExpList statement_list, args, arg_list;
non terminal Var var;
non terminal Integer addop, mulop, relop;

precedence nonassoc EQ, LT, GT, LE, GE, NE;
precedence left BOOL, INT, VOID;
precedence left RIGHT_CURLY_BRACKET, LEFT_CURLY_BRACKET;
precedence left RIGHT_PARENTHESES, LEFT_PARENTHESES, SEMI;
precedence left ID, LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET;
precedence left ELSE;
precedence left OR;
precedence left AND;
precedence left UNARY;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE;
precedence left NUM, TRUTH;

start with program;

program                         ::= declaration_list:d
                                    {:
                                        RESULT = d;
                                    :};

declaration_list                ::= declaration_list:d1 declaration:d2
                                    {:
                                        var t = d1;

                                        while (t.tail != null) {
                                            t = t.tail;
                                        }
                                        t.tail = new DecList(d2, null);
                                        RESULT = d1;
                                    :}
                                |   declaration:d
                                    {:
                                        RESULT = new DecList(d, null);
                                    :};

declaration                     ::= var_declaration:v 
                                    {:
                                        RESULT = v;
                                    :}
                                |   fun_declaration:fd
                                    {:
                                        RESULT = fd;
                                    :}
                                |   fun_prototype:fp
                                    {:
                                        RESULT = fp;
                                    :};

var_declaration                 ::= type_specifier:t ID:i SEMI
                                    {:
                                        RESULT = new SimpleDec(tleft, tright, t, i);
                                    :}
                                |   type_specifier:t error:e SEMI
                                    {:
                                        parser.report_error("Invalid variable declaration ", e);
                                        RESULT = new SimpleDec(tleft, tright, t, "");
                                    :}
                                |   type_specifier:t ID:i error:e
                                    {:
                                        parser.report_error("Expected semi colon ", e);
                                        RESULT = new SimpleDec(tleft, tright, t, i);
                                    :}
                                |   type_specifier:t ID:i LEFT_SQUARE_BRACKET NUM:n RIGHT_SQUARE_BRACKET SEMI
                                    {:
                                        int num = Integer.valueOf(n);
                                        RESULT = new ArrayDec(tleft, tright, t, i, num);
                                    :}
                                |   type_specifier:t error:e LEFT_SQUARE_BRACKET NUM:n RIGHT_SQUARE_BRACKET SEMI
                                    {:
                                        parser.report_error("Invalid variable name ", e);
                                        int num = Integer.valueOf(n);
                                        RESULT = new ArrayDec(tleft, tright, t, "", num);
                                    :}
                                |   type_specifier:t ID:i LEFT_SQUARE_BRACKET error:e RIGHT_SQUARE_BRACKET SEMI
                                    {:
                                        parser.report_error("Expected num ", e);
                                        RESULT = new ArrayDec(tleft, tright, t, i, 0);
                                    :}
                                |   type_specifier:t ID:i error:e NUM:n RIGHT_SQUARE_BRACKET SEMI
                                    {:
                                        parser.report_error("Expected left square bracket ", e);
                                        int num = Integer.valueOf(n);
                                        RESULT = new ArrayDec(tleft, tright, t, i, num);
                                    :}
                                |   type_specifier:t ID:i LEFT_SQUARE_BRACKET NUM:n error:e SEMI
                                    {:
                                        parser.report_error("Expected right square bracket ", e);
                                        int num = Integer.valueOf(n);
                                        RESULT = new ArrayDec(tleft, tright, t, i, num);
                                    :}
                                |   type_specifier:t ID:i LEFT_SQUARE_BRACKET NUM:n RIGHT_SQUARE_BRACKET error:e
                                    {:
                                        parser.report_error("Expected semi colon ", e);
                                        var num = Integer.valueOf(n);
                                        RESULT = new ArrayDec(tleft, tright, t, i, num);
                                    :}
                                |   error:e ID:i LEFT_SQUARE_BRACKET NUM:n RIGHT_SQUARE_BRACKET SEMI
                                    {:
                                        parser.report_error("Invalid type specifier ", e);
                                        var num = Integer.valueOf(n);
                                        var type_specifier = new NameTy(eleft, eright, NameTy.INVALID);
                                        RESULT = new ArrayDec(eleft, eright, type_specifier, i, num);
                                    :}
                                |   error:e ID:i SEMI
                                    {:
                                        parser.report_error("Invalid type specifier ", e);
                                        var type_specifier = new NameTy(eleft, eright, NameTy.INVALID);
                                        RESULT = new SimpleDec(eleft, eright, type_specifier, i);
                                    :};

type_specifier                  ::= BOOL:b
                                    {:
                                        RESULT = new NameTy(bleft, bright, NameTy.BOOL);
                                    :}
                                |   INT:i
                                    {:
                                        RESULT = new NameTy(ileft, iright, NameTy.INT);
                                    :}
                                |   VOID:v
                                    {:
                                        RESULT = new NameTy(vleft, vright, NameTy.VOID);
                                    :};

fun_declaration                 ::= type_specifier:t ID:i LEFT_PARENTHESES params:p RIGHT_PARENTHESES compound_stmt:c
                                    {:
                                       RESULT = new FunctionDec(tleft, tright, t, i, p, c);
                                    :}
                                |   error:e ID:i LEFT_PARENTHESES params:p RIGHT_PARENTHESES compound_stmt:c
                                    {:
                                       parser.report_error("Invalid function type specified ", e);
                                       RESULT = new FunctionDec(eleft, eright, null, i, p, c);
                                       // Use eleft and eright since there is no tleft and tright
                                    :}
                                |   type_specifier:t error:e LEFT_PARENTHESES params:p RIGHT_PARENTHESES compound_stmt:c
                                    {:
                                       parser.report_error("Invalid function name specified ", e);
                                       RESULT = new FunctionDec(tleft, tright, t, "", p, c);
                                    :}
                                |   type_specifier:t ID:i error:e params:p RIGHT_PARENTHESES compound_stmt:c
                                    {:
                                       parser.report_error("Expected left bracket ", e);
                                       RESULT = new FunctionDec(tleft, tright, t, i, p, c);
                                    :}
                                |   type_specifier:t ID:i LEFT_PARENTHESES error:e RIGHT_PARENTHESES compound_stmt:c
                                    {:
                                       parser.report_error("Invalid function parameters ", e);
                                       RESULT = new FunctionDec(tleft, tright, t, i, null, c);
                                    :}
                                |   type_specifier:t ID:i LEFT_PARENTHESES params:p error:e compound_stmt:c
                                    {:
                                       parser.report_error("Expected right bracket ", e);
                                       RESULT = new FunctionDec(tleft, tright, t, i, p, c);
                                    :};

fun_prototype                   ::= type_specifier:t ID:i LEFT_PARENTHESES params:p RIGHT_PARENTHESES SEMI
                                    {:
                                        // I'm not sure why we need to pass a position for
                                        // NilExp, but I pass the position of the closest neighbour

                                        // Gurv: If I had to guess it might have something to do with
                                        // a later checkpoint, since compilers replace all instaces of a func
                                        // when converting to machine code or something, so it will just point
                                        // to the function I guess

                                        RESULT = new FunctionDec(tleft, tright, t, i, p, new NilExp(pleft, pright));
                                    :}
                                |   error:e ID:i LEFT_PARENTHESES params:p RIGHT_PARENTHESES SEMI
                                    {:
                                        parser.report_error("Invalid function type specified ", e);
                                        RESULT = new FunctionDec(eleft, eright, null, i, p, new NilExp(pleft, pright));
                                        // Use eleft and eright since there's no t
                                    :}
                                |   type_specifier:t error:e LEFT_PARENTHESES params:p RIGHT_PARENTHESES SEMI
                                    {:
                                        parser.report_error("Invalid function name ", e);
                                        RESULT = new FunctionDec(tleft, tright, t, "", p, new NilExp(pleft, pright));
                                    :}
                                |   type_specifier:t ID:i error:e params:p RIGHT_PARENTHESES SEMI
                                    {:
                                        parser.report_error("Expected left bracket ", e);
                                        RESULT = new FunctionDec(tleft, tright, t, i, p, new NilExp(pleft, pright));
                                    :}
                                |   type_specifier:t ID:i LEFT_PARENTHESES error:e RIGHT_PARENTHESES SEMI
                                    {:
                                        parser.report_error("Invalid function parameters ", e);
                                        RESULT = new FunctionDec(tleft, tright, t, i, null, new NilExp(eleft, eright));
                                        // Use eleft and eright since there is no p
                                    :}
                                |   type_specifier:t ID:i LEFT_PARENTHESES params:p error:e SEMI
                                    {:
                                        parser.report_error("Expected right bracket ", e);
                                        RESULT = new FunctionDec(tleft, tright, t, i, p, new NilExp(pleft, pright));
                                    :}
                                |   type_specifier:t ID:i LEFT_PARENTHESES params:p RIGHT_PARENTHESES error:e
                                    {:
                                        parser.report_error("Expected semi colon ", e);
                                        RESULT = new FunctionDec(tleft, tright, t, i, p, new NilExp(pleft, pright));
                                    :};

params                          ::= param_list:pl
                                    {:
                                        RESULT = pl;
                                    :}
                                |   VOID
                                    {:
                                        RESULT = null;
                                    :};

param_list                      ::= param_list:pl COMMA param:p
                                    {:
                                        var t = pl;
                                        while (t.tail != null) {
                                            t = t.tail;
                                        }
                                        t.tail = new VarDecList(p, null);
                                        RESULT = pl;
                                    :}
                                |   param:p
                                    {:
                                        RESULT = new VarDecList(p, null);
                                    :};

param                           ::= type_specifier:t ID:i
                                    {:
                                        RESULT = new SimpleDec(tleft, tright, t, i);
                                    :}
                                |   type_specifier:t ID:i LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET
                                    {:
                                        RESULT = new ArrayDec(tleft, tright, t, i, 0);
                                    :}
                                |   type_specifier:t ID:i LEFT_SQUARE_BRACKET error:e RIGHT_SQUARE_BRACKET
                                    {:
                                        parser.report_error("Cannot assign array size to parameter ", e);
                                        RESULT = new ArrayDec(tleft, tright, t, i, 0);
                                    :}
                                |   type_specifier:t ID:i error:e RIGHT_SQUARE_BRACKET
                                    {:
                                        parser.report_error("Missing left square bracket ", e);
                                        RESULT = new ArrayDec(tleft, tright, t, i, 0);
                                    :}
                                |   type_specifier:t ID:i LEFT_SQUARE_BRACKET error:e
                                    {:
                                        parser.report_error("Missing right square bracket ", e);
                                        RESULT = new ArrayDec(tleft, tright, t, i, 0);
                                    :};

compound_stmt                   ::= LEFT_CURLY_BRACKET local_declarations:ld statement_list:sl RIGHT_CURLY_BRACKET
                                    {:
                                        RESULT = new CompoundExp(ldleft, ldright, ld, sl);
                                    :};

local_declarations              ::= local_declarations:ld var_declaration:vd
                                    {:
                                        if (ld.head == null) {
                                            ld.head = vd;
                                        } else {
                                            var t = ld;
                                            while (t.tail != null) {
                                                t = t.tail;
                                            }
                                            t.tail = new VarDecList(vd, null);
                                        }
                                        RESULT = ld;
                                    :}
                                |
                                    {:
                                        RESULT = new VarDecList(null, null);
                                    :};

statement_list                  ::= statement_list:sl statement:s
                                    {:
                                        if (sl.head == null) {
                                            sl.head = s;
                                        } else {
                                            var t = sl;
                                            while (t.tail != null) {
                                                t = t.tail;
                                            }
                                            t.tail = new ExpList(s, null);
                                        }
                                        RESULT = sl;
                                    :}
                                |
                                    {:
                                        RESULT = new ExpList(null, null);
                                    :};

statement                       ::= expression_stmt:es
                                    {:
                                        RESULT = es;
                                    :}
                                |   compound_stmt:cs
                                    {:
                                        RESULT = cs;
                                    :}
                                |   selection_stmt:ss
                                    {:
                                        RESULT = ss;
                                    :}
                                |   iteration_stmt:is
                                    {:
                                        RESULT = is;
                                    :}
                                |   return_stmt:rs
                                    {:
                                        RESULT = rs;
                                    :};

expression_stmt                 ::= expression:e SEMI
                                    {:
                                        RESULT = e;
                                    :}
                                |   SEMI:s
                                    {:
                                        RESULT = new NilExp(sleft, sright);
                                    :};

selection_stmt                  ::= IF LEFT_PARENTHESES expression:e RIGHT_PARENTHESES statement:s
                                    {:
                                        RESULT = new IfExp(eleft, eright, e, s, new NilExp(sleft, sright));
                                    :}
                                |   IF error:err expression:e RIGHT_PARENTHESES statement:s
                                    {:
                                        parser.report_error("Missing left bracket ", err);
                                        RESULT = new IfExp(eleft, eright, new NilExp(eleft, eright), s, new NilExp(sleft, sright));
                                    :}
                                |   IF LEFT_PARENTHESES error:e RIGHT_PARENTHESES statement:s
                                    {:
                                        parser.report_error("Invalid expression ", e);
                                        RESULT = new IfExp(eleft, eright, new NilExp(eleft, eright), s, new NilExp(sleft, sright));
                                    :}
                                |   IF LEFT_PARENTHESES expression:e error:err statement:s
                                    {:
                                        parser.report_error("Missing right bracket ", err);
                                        RESULT = new IfExp(eleft, eright, new NilExp(eleft, eright), s, new NilExp(sleft, sright));
                                    :}
                                |   IF LEFT_PARENTHESES expression:e RIGHT_PARENTHESES statement:s ELSE statement:s2
                                    {:
                                        RESULT = new IfExp(eleft, eright, e, s, s2);
                                    :}
                                |   IF LEFT_PARENTHESES error:e RIGHT_PARENTHESES statement:s ELSE statement:s2
                                    {:
                                        parser.report_error("Invalid expression ", e);
                                        RESULT = new IfExp(eleft, eright, new NilExp(eleft, eright), s, s2);
                                    :}
                                |   IF LEFT_PARENTHESES expression:e error:err statement:s ELSE statement:s2
                                    {:
                                        parser.report_error("Missing right bracket ", err);
                                        RESULT = new IfExp(eleft, eright, e, s, s2);
                                    :}
                                |   IF error:err expression:e RIGHT_PARENTHESES statement:s ELSE statement:s2
                                    {:
                                        parser.report_error("Missing left bracket ", err);
                                        RESULT = new IfExp(eleft, eright, e, s, s2);
                                    :};

iteration_stmt                  ::= WHILE LEFT_PARENTHESES expression:e RIGHT_PARENTHESES statement:s
                                    {:
                                        RESULT = new WhileExp(eleft, eright, e, s);
                                    :}
                                |   WHILE error:err expression:e RIGHT_PARENTHESES statement:s
                                    {:
                                        parser.report_error("Expected left bracket ", err);
                                        RESULT = new WhileExp(eleft, eright, e, s);
                                    :}
                                |   WHILE LEFT_PARENTHESES expression:e error:err statement:s
                                    {:
                                        parser.report_error("Expected right bracket ", err);
                                        RESULT = new WhileExp(eleft, eright, e, s);
                                    :}
                                |   WHILE LEFT_PARENTHESES expression:e RIGHT_PARENTHESES error:err
                                    {:
                                        parser.report_error("Expected statement after while ", err);
                                        RESULT = new WhileExp(eleft, eright, e, new NilExp(eleft, eright));
                                    :};

return_stmt                     ::= RETURN expression:e SEMI
                                    {:
                                        RESULT = new ReturnExp(eleft, eright, e);
                                    :}
                                |   RETURN:r SEMI
                                    {:
                                        RESULT = new ReturnExp(rleft, rright, new NilExp(rleft, rright));
                                    :}
                                |   RETURN error:e SEMI
                                    {:
                                        parser.report_error("Invalid expression ", e);
                                        RESULT = new ReturnExp(eleft, eright, new NilExp(eleft, eright));
                                    :}
                                |   RETURN error:e
                                    {:
                                        parser.report_error("Expected semi colon ", e);
                                        RESULT = new ReturnExp(eleft, eright, new NilExp(eleft, eright));
                                    :};

expression                      ::= var:v ASSIGN expression:e
                                    {:
                                        VarExp varExp = new VarExp(vleft, vright, v);
                                        RESULT = new AssignExp(vleft, vright, varExp, e);
                                    :}
                                |   obool_expression:obe
                                    {:
                                        RESULT = obe;
                                    :};

var                             ::= ID:i
                                    {:
                                        RESULT = new SimpleVar(ileft, iright, i);
                                    :}
                                |   ID:i LEFT_SQUARE_BRACKET expression:e RIGHT_SQUARE_BRACKET
                                    {:
                                        RESULT = new IndexVar(ileft, iright, i, e);
                                    :}
                                |   ID:i LEFT_SQUARE_BRACKET error:err RIGHT_SQUARE_BRACKET
                                    {:
                                        parser.report_error("Invalid variable ", err);
                                        RESULT = new IndexVar(ileft, iright, i, new NilExp(errleft, errright));
                                    :}
                                |   ID:i error:err expression:e RIGHT_SQUARE_BRACKET
                                    {:
                                        parser.report_error("Missing left bracket ", err);
                                        RESULT = new IndexVar(ileft, iright, i, e);
                                    :}
                                |   ID:i LEFT_SQUARE_BRACKET expression:e error:err
                                    {:
                                        parser.report_error("Missing right bracket ", err);
                                        RESULT = new IndexVar(ileft, iright, i, e);
                                    :};

obool_expression                ::= obool_expression:obe OR abool_expression:abe
                                    {:
                                        RESULT = new OpExp(obeleft, oberight, obe, OpExp.OR, abe);
                                    :}
                                |   abool_expression:abe
                                    {:
                                        RESULT = abe;
                                    :};

abool_expression                ::= abool_expression:abe AND ubool_expression:ube
                                    {:
                                        RESULT = new OpExp(abeleft, aberight, abe, OpExp.AND, ube);
                                    :}
                                |   ubool_expression:ube
                                    {:
                                        RESULT = ube;
                                    :};

ubool_expression                ::= UNARY ubool_expression:ube
                                    {:
                                        RESULT = new OpExp(ubeleft, uberight, new NilExp(ubeleft, uberight), OpExp.UMINUS, ube);
                                    :}
                                |   simple_expression:se
                                    {:
                                        RESULT = se;
                                    :};

simple_expression               ::= additive_expression:ae relop:ro additive_expression:ae2
                                    {:
                                        RESULT = new OpExp(aeleft, aeright, ae, ro, ae2);
                                    :}
                                |   additive_expression:ae
                                    {:
                                        RESULT = ae;
                                    :};

relop                           ::= LE
                                    {:
                                        RESULT = OpExp.LE;
                                    :}
                                |   LT
                                    {:
                                        RESULT = OpExp.LT;
                                    :}
                                |   GT
                                    {:
                                        RESULT = OpExp.GT;
                                    :}
                                |   GE
                                    {:
                                        RESULT = OpExp.GE;
                                    :}
                                |   EQ
                                    {:
                                        RESULT = OpExp.EQ;
                                    :}
                                |   NE
                                    {:
                                        RESULT = OpExp.NE;
                                    :};

additive_expression             ::= additive_expression:ae addop:ao term:t
                                    {:
                                        RESULT = new OpExp(aeleft, aeright, ae, ao, t);
                                    :}
                                |   term:t
                                    {:
                                        RESULT = t;
                                    :};

addop                           ::= PLUS
                                    {:
                                        RESULT = OpExp.PLUS;
                                    :}
                                |   MINUS
                                    {:
                                        RESULT = OpExp.MINUS;
                                    :};

term                            ::= term:t mulop:m signed_factor:sf
                                    {:
                                        RESULT = new OpExp(tleft, tright, t, m, sf);
                                    :}
                                |   signed_factor:sf
                                    {:
                                        RESULT = sf;
                                    :};

mulop                           ::= MULTIPLY
                                    {:
                                        RESULT = OpExp.MULTIPLY;
                                    :}
                                |   DIVIDE
                                    {:
                                        RESULT = OpExp.DIVIDE;
                                    :};

signed_factor                   ::= MINUS:m signed_factor:sf
                                    {:
                                        // NIL exp is used since there is no expression on the left hand side
                                        RESULT = new OpExp(mleft, mright, new NilExp(mleft, mright) , OpExp.MINUS, sf);
                                    :}
                                |   factor:f
                                    {:
                                        RESULT = f;
                                    :};

factor                          ::= LEFT_PARENTHESES expression:e RIGHT_PARENTHESES
                                    {:
                                        RESULT = e;
                                    :}
                                |   LEFT_PARENTHESES expression:e error:err
                                    {:
                                        parser.report_error("Missing right bracket ", err);
                                        RESULT = e;
                                    :}
                                |   var:v
                                    {:
                                        VarExp varExp = new VarExp(vleft, vright, v);
                                        RESULT = varExp;
                                    :}
                                |   call:c
                                    {:
                                        RESULT = c;
                                    :}
                                |   NUM:n
                                    {:
                                        int num = Integer.valueOf(n);
                                        RESULT = new IntExp(nleft, nright, num);
                                    :}
                                |   TRUTH:t
                                    {:
                                        boolean value = Boolean.parseBoolean(t);
                                        RESULT = new BoolExp(tleft, tright, value);
                                    :};

call                            ::= ID:i LEFT_PARENTHESES args:a RIGHT_PARENTHESES
                                    {:
                                        RESULT = new CallExp(ileft, iright, i, a);
                                    :}
                                |   ID:i LEFT_PARENTHESES error:e RIGHT_PARENTHESES
                                    {:
                                        parser.report_error("Invalid arguments ", e);
                                        RESULT = new CallExp(ileft, iright, i, null);
                                    :};

args                            ::= arg_list:a
                                    {:
                                        RESULT = a;
                                    :}
                                |
                                    {:
                                        RESULT = null;
                                    :};

arg_list                        ::= arg_list:a COMMA expression:e
                                    {:
                                        var t = a;
                                        while (t.tail != null) {
                                            t = t.tail;
                                        }
                                        t.tail = new ExpList(e, null);
                                        RESULT = a;
                                    :}
                                |   expression:e
                                    {:
                                        RESULT = new ExpList(e, null);
                                    :};
