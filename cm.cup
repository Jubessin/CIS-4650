/*
* File Name: cm.cup
* TODO: File description
*/

import absyn.*;


terminal IF, WHILE, BOOL, INT, VOID, COMMA, SEMI, RETURN;
terminal LEFT_PARENTHESES, RIGHT_PARENTHESES, LEFT_CURLY_BRACKET, RIGHT_CURLY_BRACKET, LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET;
terminal MULTIPLY, PLUS, MINUS, DIVIDE;
terminal AND, EQ, OR, ELSE, LT, GT, LE, GE, NE, UNARY, ASSIGN;
terminal String ID, NUM, TRUTH;

non terminal NameTy type_specifier;
non terminal DecList program, declaration_list;
non terminal FunctionDec fun_declaration, fun_prototype;
non terminal Dec declaration; 
non terminal VarDec var_declaration, param;
non terminal VarDecList params, param_list, local_declarations;
non terminal Exp statement, expression_stmt, expression, obool_expression, abool_expression, ubool_expression, simple_expression, additive_expression, term, signed_factor, factor, call;
non terminal IfExp selection_stmt;
non terminal WhileExp iteration_stmt;
non terminal ReturnExp return_stmt;
non terminal CompoundExp compound_stmt;
non terminal ExpList statement_list, args, arg_list;
non terminal Var var;
non terminal Integer addop, mulop, relop;

start with program;

program                         ::= declaration_list:d
                                    {:
                                        System.out.println("Completed program");
                                        RESULT = d;
                                    :};

declaration_list                ::= declaration_list:d1 declaration:d2
                                    {:
                                        System.out.println("declaration list");
                                        var t = d1;

                                        while (t.tail != null) {
                                            t = t.tail;
                                        }
                                        t.tail = new DecList(d2, null);
                                        RESULT = d1;
                                    :}
                                |   declaration:d
                                    {:
                                        System.out.println("declaration");
                                        RESULT = new DecList(d, null);
                                    :};

declaration                     ::= var_declaration:v 
                                    {:
                                        RESULT = v;
                                    :}
                                |   fun_declaration:fd
                                    {:
                                        RESULT = fd;
                                    :}
                                |   fun_prototype:fp
                                    {:
                                        RESULT = fp;
                                    :};

var_declaration                 ::= type_specifier:t ID:i SEMI
                                    {:
                                        System.out.println("simple declaration");
                                        RESULT = new SimpleDec(tleft, tright, t, i);
                                    :}
                                |   type_specifier:t error:e SEMI
                                    {:
                                        parser.report_error("Invalid variable declaration ", e, eleft, eright);
                                        RESULT = new SimpleDec(tleft, tright, t, "");
                                    :}
                                |   type_specifier:t ID:i error:e
                                    {:
                                        parser.report_error("Expected semi colon ", e, eleft, eright);
                                        RESULT = new SimpleDec(tleft, tright, t, i);
                                    :}
                                |   type_specifier:t ID:i LEFT_SQUARE_BRACKET NUM:n RIGHT_SQUARE_BRACKET SEMI
                                    {:
                                        System.out.println("array declaration");
                                        int num = Integer.valueOf(n);
                                        RESULT = new ArrayDec(tleft, tright, t, i, num);
                                    :}
                                |   type_specifier:t error:e LEFT_SQUARE_BRACKET NUM:n RIGHT_SQUARE_BRACKET SEMI
                                    {:
                                        parser.report_error("Invalid variable name ", e, eleft, eright);
                                        RESULT = new ArrayDec(tleft, tright, t, "", num);
                                    :}
                                |   type_specifier:t ID:i error:e NUM:n RIGHT_SQUARE_BRACKET SEMI
                                    {:
                                        parser.report_error("Expected left square bracket ", e, eleft, eright);
                                        RESULT = new ArrayDec(tleft, tright, t, i, num);
                                    :}
                                |   type_specifier:t ID:i LEFT_SQUARE_BRACKET error:e RIGHT_SQUARE_BRACKET SEMI
                                    {:
                                        parser.report_error("Expected num ", e, eleft, eright);
                                        RESULT = new ArrayDec(tleft, tright, t, i, 0);
                                    :}
                                |   type_specifier:t ID:i LEFT_SQUARE_BRACKET NUM:n error:e SEMI
                                    {:
                                        parser.report_error("Expected right square bracket ", e, eleft, eright);
                                        RESULT = new ArrayDec(tleft, tright, t, i, num);
                                    :}
                                |   type_specifier:t ID:i LEFT_SQUARE_BRACKET NUM:n RIGHT_SQUARE_BRACKET error:e
                                    {:
                                        parser.report_error("Expected semi colon ", e, eleft, eright);
                                        RESULT = new ArrayDec(tleft, tright, t, i, num);
                                    :};

type_specifier                  ::= BOOL:b
                                    {:
                                        System.out.println("bool");
                                        RESULT = new NameTy(bleft, bright, NameTy.Bool);
                                    :}
                                |   INT:i
                                    {:
                                        System.out.println("int");
                                        RESULT = new NameTy(ileft, iright, NameTy.Int);
                                    :}
                                |   VOID:v
                                    {:
                                        System.out.println("void");
                                        RESULT = new NameTy(vleft, vright, NameTy.Void);
                                    :};

fun_declaration                 ::= type_specifier:t ID:i LEFT_PARENTHESES params:p RIGHT_PARENTHESES compound_stmt:c
                                    {:
                                       System.out.println("function declaration");
                                       RESULT = new FunctionDec(tleft, tright, t, i, p, c);
                                    :}
                                |   error:e ID:i LEFT_PARENTHESES params:p RIGHT_PARENTHESES compound_stmt:c
                                    {:
                                       parser.report_error("Invalid function type specified ", e, eleft, eright);
                                       RESULT = new FunctionDec(eleft, eright, t, i, p, c);
                                       // Use eleft and eright since there is no tleft and tright
                                    :}
                                |   type_specifier:t error:e LEFT_PARENTHESES params:p RIGHT_PARENTHESES compound_stmt:c
                                    {:
                                       parser.report_error("Invalid function name specified ", e, eleft, eright);
                                       RESULT = new FunctionDec(tleft, tright, t, "", p, c);
                                    :}
                                |   type_specifier:t ID:i error:e params:p RIGHT_PARENTHESES compound_stmt:c
                                    {:
                                       parser.report_error("Expected left bracket ", e, eleft, eright);
                                       RESULT = new FunctionDec(tleft, tright, t, i, p, c);
                                    :}
                                |   type_specifier:t ID:i LEFT_PARENTHESES error:e RIGHT_PARENTHESES compound_stmt:c
                                    {:
                                       parser.report_error("Invalid function parameters ", e, eleft, eright);
                                       RESULT = new FunctionDec(tleft, tright, t, i, null, c);
                                |   type_specifier:t ID:i LEFT_PARENTHESES ID:i error:e compound_stmt:c
                                    {:
                                       parser.report_error("Expected right bracket ", e, eleft, eright);
                                       RESULT = new FunctionDec(tleft, tright, t, i, p, c);
                                    :}
                                |   type_specifier:t ID:i LEFT_PARENTHESES params:p RIGHT_PARENTHESES error:e
                                    {:
                                       parser.report_error("Invalid compound statement ", e, eleft, eright);
                                       RESULT = new FunctionDec(tleft, tright, t, i, p, null);
                                       // Not sure if this is necessary, as we travel up the tree from the bottom
                                       // somethings are guaranteed to exist properly by then assuming we
                                       // error check them lower in the tree right? Idk I could be wrong
                                    :};

fun_prototype                   ::= type_specifier:t ID:i LEFT_PARENTHESES params:p RIGHT_PARENTHESES SEMI
                                    {:
                                        System.out.println("function declaration");
                                        // I'm not sure why we need to pass a position for
                                        // NilExp, but I pass the position of the closest neighbour

                                        // Gurv: If I had to guess it might have something to do with
                                        // a later checkpoint, since compilers replace all instaces of a func
                                        // when converting to machine code or something, so it will just point
                                        // to the function I guess

                                        RESULT = new FunctionDec(tleft, tright, t, i, p, new NilExp(pleft, pright));
                                    :}
                                |   error:e ID:i LEFT_PARENTHESES params:p RIGHT_PARENTHESES SEMI
                                    {:
                                        parser.report_error("Invalid function type specified ", e, eleft, eright);
                                        RESULT = new FunctionDec(eleft, eright, null, i, p, new NilExp(pleft, pright));
                                        // Use eleft and eright since there's no t
                                    :}
                                |   type_specifier:t error:e LEFT_PARENTHESES params:p RIGHT_PARENTHESES SEMI
                                    {:
                                        parser.report_error("Invalid function name ", e, eleft, eright);
                                        RESULT = new FunctionDec(tleft, tright, t, "", p, new NilExp(pleft, pright));
                                    :}
                                |   type_specifier:t ID:i error:e params:p RIGHT_PARENTHESES SEMI
                                    {:
                                        parser.report_error("Expected left bracket ", e, eleft, eright);
                                        RESULT = new FunctionDec(tleft, tright, t, i, p, new NilExp(pleft, pright));
                                    :}
                                |   type_specifier:t ID:i LEFT_PARENTHESES error:e RIGHT_PARENTHESES SEMI
                                    {:
                                        parser.report_error("Invalid function parameters ", e, eleft, eright);
                                        RESULT = new FunctionDec(tleft, tright, t, i, null, new NilExp(eleft, eright));
                                        // Use eleft and eright since there is no p
                                    :}
                                |   type_specifier:t ID:i LEFT_PARENTHESES params:p error:e SEMI
                                    {:
                                        parser.report_error("Expected right bracket ", e, eleft, eright);
                                        RESULT = new FunctionDec(tleft, tright, t, i, p, new NilExp(pleft, pright));
                                    :}
                                |   type_specifier:t ID:i LEFT_PARENTHESES params:p RIGHT_PARENTHESES error:e
                                    {:
                                        parser.report_error("Expected semi colon ", e, eleft, eright);
                                        RESULT = new FunctionDec(tleft, tright, t, i, p, new NilExp(pleft, pright));
                                    :};

params                          ::= param_list:pl
                                    {:
                                        System.out.println("total list of params");
                                        RESULT = pl;
                                    :}
                                |   VOID
                                    {:
                                        System.out.println("void params");
                                        RESULT = null;
                                    :};

param_list                      ::= param_list:pl COMMA param:p
                                    {:
                                        System.out.println("param list");
                                        var t = pl;
                                        while (t.tail != null) {
                                            t = t.tail;
                                        }
                                        t.tail = new VarDecList(p, null);
                                        RESULT = pl;
                                    :}
                                |   param:p
                                    {:
                                        System.out.println("initialized param list");
                                        RESULT = new VarDecList(p, null);
                                    :};

param                           ::= type_specifier:t ID:i
                                    {:
                                        System.out.println("simple declaration");
                                        RESULT = new SimpleDec(tleft, tright, t, i);
                                    :}
                                |   type_specifier:t ID:i LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET
                                    {:
                                        System.out.println("array declaration");
                                        RESULT = new ArrayDec(tleft, tright, t, i, 0);
                                    :};

compound_stmt                   ::= LEFT_CURLY_BRACKET local_declarations:ld statement_list:sl RIGHT_CURLY_BRACKET
                                    {:
                                        RESULT = new CompoundExp(ldleft, ldright, ld, sl);
                                    :};

local_declarations              ::= local_declarations:ld var_declaration:vd
                                    {:
                                        System.out.println("local declarations");
                                        if (ld.head == null) {
                                            ld.head = vd;
                                        } else {
                                            var t = ld;
                                            while (t.tail != null) {
                                                t = t.tail;
                                            }
                                            t.tail = new VarDecList(vd, null);
                                        }
                                        RESULT = ld;
                                    :}
                                |
                                    {:
                                        RESULT = new VarDecList(null, null);
                                    :};

statement_list                  ::= statement_list:sl statement:s
                                    {:
                                        if (sl.head == null) {
                                            sl.head = s;
                                        } else {
                                            var t = sl;
                                            while (t.tail != null) {
                                                t = t.tail;
                                            }
                                            t.tail = new ExpList(s, null);
                                        }
                                        RESULT = sl;
                                    :}
                                |
                                    {:
                                        System.out.println("created statement list");

                                        RESULT = new ExpList(null, null);
                                    :};

statement                       ::= expression_stmt:es
                                    {:
                                        System.out.println("expression statement");
                                        RESULT = es;
                                    :}
                                |   compound_stmt:cs
                                    {:
                                        System.out.println("compound statement");
                                        RESULT = cs;
                                    :}
                                |   selection_stmt:ss
                                    {:
                                        System.out.println("if statement");
                                        RESULT = ss;
                                    :}
                                |   iteration_stmt:is
                                    {:
                                        System.out.println("iteration/while statement");
                                        RESULT = is;
                                    :}
                                |   return_stmt:rs
                                    {:
                                        System.out.println("return statement");
                                        RESULT = rs;
                                    :};

expression_stmt                 ::= expression:e SEMI
                                    {:
                                        RESULT = e;
                                    :}
                                |   SEMI:s
                                    {:
                                        RESULT = new NilExp(sleft, sright);
                                    :};

selection_stmt                  ::= IF LEFT_PARENTHESES expression:e RIGHT_PARENTHESES statement:s
                                    {:
                                        RESULT = new IfExp(eleft, eright, e, s, new NilExp(sleft, sright));
                                    :}
                                |   IF LEFT_PARENTHESES expression:e RIGHT_PARENTHESES statement:s ELSE statement:s2
                                    {:
                                        RESULT = new IfExp(eleft, eright, e, s, s2);
                                    :};

iteration_stmt                  ::= WHILE LEFT_PARENTHESES expression:e RIGHT_PARENTHESES statement:s
                                    {:
                                        RESULT = new WhileExp(eleft, eright, e, s);
                                    :};

return_stmt                  ::= RETURN expression:e SEMI
                                    {:
                                        RESULT = new ReturnExp(eleft, eright, e);
                                    :}
                                |   RETURN:r SEMI
                                    {:
                                        RESULT = new ReturnExp(rleft, rright, new NilExp(rleft, rright));
                                    :};

expression                      ::= var:v ASSIGN expression:e
                                    {:
                                        VarExp varExp = new VarExp(vleft, vright, v);
                                        RESULT = new AssignExp(vleft, vright, varExp, e);
                                    :}
                                |   obool_expression:obe
                                    {:
                                        RESULT = obe;
                                    :};

var                             ::= ID:i
                                    {:
                                        RESULT = new SimpleVar(ileft, iright, i);
                                    :}
                                |   ID:i LEFT_SQUARE_BRACKET expression:e RIGHT_SQUARE_BRACKET
                                    {:
                                        RESULT = new IndexVar(ileft, iright, i, e);
                                    :};

obool_expression                ::= obool_expression:obe OR abool_expression:abe
                                    {:
                                        RESULT = new OpExp(obeleft, oberight, obe, OpExp.OR, abe);
                                    :}
                                |   abool_expression:abe
                                    {:
                                        RESULT = abe;
                                    :};

abool_expression                ::= abool_expression:abe AND ubool_expression:ube
                                    {:
                                        RESULT = new OpExp(abeleft, aberight, abe, OpExp.AND, ube);
                                    :}
                                |   ubool_expression:ube
                                    {:
                                        RESULT = ube;
                                    :};

ubool_expression                ::= UNARY ubool_expression:ube
                                    {:
                                        RESULT = new OpExp(ubeleft, uberight, new NilExp(ubeleft, uberight), OpExp.AND, ube);
                                    :}
                                |   simple_expression:se
                                    {:
                                        RESULT = se;
                                    :};

simple_expression               ::= additive_expression:ae relop:ro additive_expression:ae2
                                    {:
                                        RESULT = new OpExp(aeleft, aeright, ae, ro, ae2);
                                    :}
                                |   additive_expression:ae
                                    {:
                                        RESULT = ae;
                                    :};

relop                           ::= LE
                                    {:
                                        RESULT = OpExp.LE;
                                    :}
                                |   LT
                                    {:
                                        RESULT = OpExp.LT;
                                    :}
                                |   GT
                                    {:
                                        RESULT = OpExp.GT;
                                    :}
                                |   GE
                                    {:
                                        RESULT = OpExp.GE;
                                    :}
                                |   EQ
                                    {:
                                        RESULT = OpExp.EQ;
                                    :}
                                |   NE
                                    {:
                                        RESULT = OpExp.NE;
                                    :};

additive_expression             ::= additive_expression:ae addop:ao term:t
                                    {:
                                        RESULT = new OpExp(aeleft, aeright, ae, ao, t);
                                    :}
                                |   term:t
                                    {:
                                        RESULT = t;
                                    :};

addop                           ::= PLUS
                                    {:
                                        RESULT = OpExp.PLUS;
                                    :}
                                |   MINUS
                                    {:
                                        RESULT = OpExp.MINUS;
                                    :};

term                            ::= term:t mulop:m signed_factor:sf
                                    {:
                                        RESULT = new OpExp(tleft, tright, t, m, sf);
                                    :}
                                |   signed_factor:sf
                                    {:
                                        RESULT = sf;
                                    :};

mulop                           ::= MULTIPLY
                                    {:
                                        RESULT = OpExp.MULTIPLY;
                                    :}
                                |   DIVIDE
                                    {:
                                        RESULT = OpExp.DIVIDE;
                                    :};

signed_factor                   ::= MINUS:m signed_factor:sf
                                    {:
                                        // NIL exp is used since there is no expression on the left hand side
                                        RESULT = new OpExp(mleft, mright, new NilExp(mleft, mright) , OpExp.MINUS, sf);
                                    :}
                                |   factor:f
                                    {:
                                        RESULT = f;
                                    :};

factor                          ::= LEFT_PARENTHESES expression:e RIGHT_PARENTHESES
                                    {:
                                        RESULT = e;
                                    :}
                                |   var:v
                                    {:
                                        VarExp varExp = new VarExp(vleft, vright, v);
                                        RESULT = varExp;
                                    :}
                                |   call:c
                                    {:
                                        RESULT = c;
                                    :}
                                |   NUM:n
                                    {:
                                        int num = Integer.valueOf(n);
                                        RESULT = new IntExp(nleft, nright, num);
                                    :}
                                |   TRUTH:t
                                    {:
                                        boolean value = Boolean.parseBoolean(t);
                                        RESULT = new BoolExp(tleft, tright, value);
                                    :};

call                            ::= ID:i LEFT_PARENTHESES args:a RIGHT_PARENTHESES
                                    {:
                                        RESULT = new CallExp(ileft, iright, i, a);
                                    :};

args                            ::= arg_list:a
                                    {:
                                        RESULT = a;
                                    :}
                                |
                                    {:
                                        RESULT = null;
                                    :};

arg_list                        ::= arg_list:a COMMA expression:e
                                    {:
                                        var t = a;
                                        while (t.tail != null) {
                                            t = t.tail;
                                        }
                                        t.tail = new ExpList(e, null);
                                        RESULT = a;
                                    :}
                                |   expression:e
                                    {:
                                        RESULT = new ExpList(e, null);
                                    :};
